// Code generated by protoc-gen-go. DO NOT EDIT.
// source: kubemq.proto

/*
Package kubemq is a generated protocol buffer package.

It is generated from these files:
	kubemq.proto

It has these top-level messages:
	Empty
	Result
	Event
	EventReceive
	Subscribe
	Request
	Response
*/
package kubemq

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Subscribe_SubscribeType int32

const (
	Subscribe_SubscribeTypeUndefined Subscribe_SubscribeType = 0
	Subscribe_Events                 Subscribe_SubscribeType = 1
	Subscribe_EventsStore            Subscribe_SubscribeType = 2
	Subscribe_Commands               Subscribe_SubscribeType = 3
	Subscribe_Queries                Subscribe_SubscribeType = 4
)

var Subscribe_SubscribeType_name = map[int32]string{
	0: "SubscribeTypeUndefined",
	1: "Events",
	2: "EventsStore",
	3: "Commands",
	4: "Queries",
}
var Subscribe_SubscribeType_value = map[string]int32{
	"SubscribeTypeUndefined": 0,
	"Events":                 1,
	"EventsStore":            2,
	"Commands":               3,
	"Queries":                4,
}

func (x Subscribe_SubscribeType) String() string {
	return proto.EnumName(Subscribe_SubscribeType_name, int32(x))
}
func (Subscribe_SubscribeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type Subscribe_EventsStoreType int32

const (
	Subscribe_EventsStoreTypeUndefined Subscribe_EventsStoreType = 0
	Subscribe_StartNewOnly             Subscribe_EventsStoreType = 1
	Subscribe_StartFromFirst           Subscribe_EventsStoreType = 2
	Subscribe_StartFromLast            Subscribe_EventsStoreType = 3
	Subscribe_StartAtSequence          Subscribe_EventsStoreType = 4
	Subscribe_StartAtTime              Subscribe_EventsStoreType = 5
	Subscribe_StartAtTimeDelta         Subscribe_EventsStoreType = 6
)

var Subscribe_EventsStoreType_name = map[int32]string{
	0: "EventsStoreTypeUndefined",
	1: "StartNewOnly",
	2: "StartFromFirst",
	3: "StartFromLast",
	4: "StartAtSequence",
	5: "StartAtTime",
	6: "StartAtTimeDelta",
}
var Subscribe_EventsStoreType_value = map[string]int32{
	"EventsStoreTypeUndefined": 0,
	"StartNewOnly":             1,
	"StartFromFirst":           2,
	"StartFromLast":            3,
	"StartAtSequence":          4,
	"StartAtTime":              5,
	"StartAtTimeDelta":         6,
}

func (x Subscribe_EventsStoreType) String() string {
	return proto.EnumName(Subscribe_EventsStoreType_name, int32(x))
}
func (Subscribe_EventsStoreType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1} }

type Request_RequestType int32

const (
	Request_RequestTypeUnknown Request_RequestType = 0
	Request_Command            Request_RequestType = 1
	Request_Query              Request_RequestType = 2
)

var Request_RequestType_name = map[int32]string{
	0: "RequestTypeUnknown",
	1: "Command",
	2: "Query",
}
var Request_RequestType_value = map[string]int32{
	"RequestTypeUnknown": 0,
	"Command":            1,
	"Query":              2,
}

func (x Request_RequestType) String() string {
	return proto.EnumName(Request_RequestType_name, int32(x))
}
func (Request_RequestType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Result struct {
	EventID string `protobuf:"bytes,1,opt,name=EventID" json:"EventID,omitempty"`
	Sent    bool   `protobuf:"varint,2,opt,name=Sent" json:"Sent,omitempty"`
	Error   string `protobuf:"bytes,3,opt,name=Error" json:"Error,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Result) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *Result) GetSent() bool {
	if m != nil {
		return m.Sent
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Event struct {
	EventID  string `protobuf:"bytes,1,opt,name=EventID" json:"EventID,omitempty"`
	ClientID string `protobuf:"bytes,2,opt,name=ClientID" json:"ClientID,omitempty"`
	Channel  string `protobuf:"bytes,3,opt,name=Channel" json:"Channel,omitempty"`
	Metadata string `protobuf:"bytes,4,opt,name=Metadata" json:"Metadata,omitempty"`
	Body     []byte `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	Store    bool   `protobuf:"varint,6,opt,name=Store" json:"Store,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Event) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *Event) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Event) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Event) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Event) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Event) GetStore() bool {
	if m != nil {
		return m.Store
	}
	return false
}

type EventReceive struct {
	EventID   string `protobuf:"bytes,1,opt,name=EventID" json:"EventID,omitempty"`
	Channel   string `protobuf:"bytes,2,opt,name=Channel" json:"Channel,omitempty"`
	Metadata  string `protobuf:"bytes,3,opt,name=Metadata" json:"Metadata,omitempty"`
	Body      []byte `protobuf:"bytes,4,opt,name=Body,proto3" json:"Body,omitempty"`
	Timestamp int64  `protobuf:"varint,5,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Sequence  uint64 `protobuf:"varint,6,opt,name=Sequence" json:"Sequence,omitempty"`
}

func (m *EventReceive) Reset()                    { *m = EventReceive{} }
func (m *EventReceive) String() string            { return proto.CompactTextString(m) }
func (*EventReceive) ProtoMessage()               {}
func (*EventReceive) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EventReceive) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *EventReceive) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *EventReceive) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *EventReceive) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *EventReceive) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EventReceive) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

type Subscribe struct {
	SubscribeTypeData    Subscribe_SubscribeType   `protobuf:"varint,1,opt,name=SubscribeTypeData,enum=kubemq.Subscribe_SubscribeType" json:"SubscribeTypeData,omitempty"`
	ClientID             string                    `protobuf:"bytes,2,opt,name=ClientID" json:"ClientID,omitempty"`
	Channel              string                    `protobuf:"bytes,3,opt,name=Channel" json:"Channel,omitempty"`
	Group                string                    `protobuf:"bytes,4,opt,name=Group" json:"Group,omitempty"`
	EventsStoreTypeData  Subscribe_EventsStoreType `protobuf:"varint,5,opt,name=EventsStoreTypeData,enum=kubemq.Subscribe_EventsStoreType" json:"EventsStoreTypeData,omitempty"`
	EventsStoreTypeValue int64                     `protobuf:"varint,6,opt,name=EventsStoreTypeValue" json:"EventsStoreTypeValue,omitempty"`
}

func (m *Subscribe) Reset()                    { *m = Subscribe{} }
func (m *Subscribe) String() string            { return proto.CompactTextString(m) }
func (*Subscribe) ProtoMessage()               {}
func (*Subscribe) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Subscribe) GetSubscribeTypeData() Subscribe_SubscribeType {
	if m != nil {
		return m.SubscribeTypeData
	}
	return Subscribe_SubscribeTypeUndefined
}

func (m *Subscribe) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Subscribe) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Subscribe) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Subscribe) GetEventsStoreTypeData() Subscribe_EventsStoreType {
	if m != nil {
		return m.EventsStoreTypeData
	}
	return Subscribe_EventsStoreTypeUndefined
}

func (m *Subscribe) GetEventsStoreTypeValue() int64 {
	if m != nil {
		return m.EventsStoreTypeValue
	}
	return 0
}

type Request struct {
	RequestID       string              `protobuf:"bytes,1,opt,name=RequestID" json:"RequestID,omitempty"`
	RequestTypeData Request_RequestType `protobuf:"varint,2,opt,name=RequestTypeData,enum=kubemq.Request_RequestType" json:"RequestTypeData,omitempty"`
	ClientID        string              `protobuf:"bytes,3,opt,name=ClientID" json:"ClientID,omitempty"`
	Channel         string              `protobuf:"bytes,4,opt,name=Channel" json:"Channel,omitempty"`
	Metadata        string              `protobuf:"bytes,5,opt,name=Metadata" json:"Metadata,omitempty"`
	Body            []byte              `protobuf:"bytes,6,opt,name=Body,proto3" json:"Body,omitempty"`
	ReplyChannel    string              `protobuf:"bytes,7,opt,name=ReplyChannel" json:"ReplyChannel,omitempty"`
	Timeout         int32               `protobuf:"varint,8,opt,name=Timeout" json:"Timeout,omitempty"`
	CacheKey        string              `protobuf:"bytes,9,opt,name=CacheKey" json:"CacheKey,omitempty"`
	CacheTTL        int32               `protobuf:"varint,10,opt,name=CacheTTL" json:"CacheTTL,omitempty"`
	Span            []byte              `protobuf:"bytes,11,opt,name=Span,proto3" json:"Span,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Request) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Request) GetRequestTypeData() Request_RequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return Request_RequestTypeUnknown
}

func (m *Request) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Request) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Request) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Request) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Request) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Request) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *Request) GetCacheKey() string {
	if m != nil {
		return m.CacheKey
	}
	return ""
}

func (m *Request) GetCacheTTL() int32 {
	if m != nil {
		return m.CacheTTL
	}
	return 0
}

func (m *Request) GetSpan() []byte {
	if m != nil {
		return m.Span
	}
	return nil
}

type Response struct {
	ClientID     string `protobuf:"bytes,1,opt,name=ClientID" json:"ClientID,omitempty"`
	RequestID    string `protobuf:"bytes,2,opt,name=RequestID" json:"RequestID,omitempty"`
	ReplyChannel string `protobuf:"bytes,3,opt,name=ReplyChannel" json:"ReplyChannel,omitempty"`
	Metadata     string `protobuf:"bytes,4,opt,name=Metadata" json:"Metadata,omitempty"`
	Body         []byte `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	CacheHit     bool   `protobuf:"varint,6,opt,name=CacheHit" json:"CacheHit,omitempty"`
	Timestamp    int64  `protobuf:"varint,7,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Executed     bool   `protobuf:"varint,8,opt,name=Executed" json:"Executed,omitempty"`
	Error        string `protobuf:"bytes,9,opt,name=Error" json:"Error,omitempty"`
	Span         []byte `protobuf:"bytes,10,opt,name=Span,proto3" json:"Span,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Response) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Response) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Response) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Response) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Response) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Response) GetCacheHit() bool {
	if m != nil {
		return m.CacheHit
	}
	return false
}

func (m *Response) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Response) GetExecuted() bool {
	if m != nil {
		return m.Executed
	}
	return false
}

func (m *Response) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Response) GetSpan() []byte {
	if m != nil {
		return m.Span
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "kubemq.Empty")
	proto.RegisterType((*Result)(nil), "kubemq.Result")
	proto.RegisterType((*Event)(nil), "kubemq.Event")
	proto.RegisterType((*EventReceive)(nil), "kubemq.EventReceive")
	proto.RegisterType((*Subscribe)(nil), "kubemq.Subscribe")
	proto.RegisterType((*Request)(nil), "kubemq.Request")
	proto.RegisterType((*Response)(nil), "kubemq.Response")
	proto.RegisterEnum("kubemq.Subscribe_SubscribeType", Subscribe_SubscribeType_name, Subscribe_SubscribeType_value)
	proto.RegisterEnum("kubemq.Subscribe_EventsStoreType", Subscribe_EventsStoreType_name, Subscribe_EventsStoreType_value)
	proto.RegisterEnum("kubemq.Request_RequestType", Request_RequestType_name, Request_RequestType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Kubemq service

type KubemqClient interface {
	SendEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Result, error)
	SendEventsStream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_SendEventsStreamClient, error)
	SubscribeToEvents(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToEventsClient, error)
	SubscribeToRequests(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToRequestsClient, error)
	SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error)
}

type kubemqClient struct {
	cc *grpc.ClientConn
}

func NewKubemqClient(cc *grpc.ClientConn) KubemqClient {
	return &kubemqClient{cc}
}

func (c *kubemqClient) SendEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/kubemq.kubemq/SendEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendEventsStream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_SendEventsStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Kubemq_serviceDesc.Streams[0], c.cc, "/kubemq.kubemq/SendEventsStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSendEventsStreamClient{stream}
	return x, nil
}

type Kubemq_SendEventsStreamClient interface {
	Send(*Event) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type kubemqSendEventsStreamClient struct {
	grpc.ClientStream
}

func (x *kubemqSendEventsStreamClient) Send(m *Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqSendEventsStreamClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SubscribeToEvents(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToEventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Kubemq_serviceDesc.Streams[1], c.cc, "/kubemq.kubemq/SubscribeToEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSubscribeToEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Kubemq_SubscribeToEventsClient interface {
	Recv() (*EventReceive, error)
	grpc.ClientStream
}

type kubemqSubscribeToEventsClient struct {
	grpc.ClientStream
}

func (x *kubemqSubscribeToEventsClient) Recv() (*EventReceive, error) {
	m := new(EventReceive)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SubscribeToRequests(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToRequestsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Kubemq_serviceDesc.Streams[2], c.cc, "/kubemq.kubemq/SubscribeToRequests", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSubscribeToRequestsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Kubemq_SubscribeToRequestsClient interface {
	Recv() (*Request, error)
	grpc.ClientStream
}

type kubemqSubscribeToRequestsClient struct {
	grpc.ClientStream
}

func (x *kubemqSubscribeToRequestsClient) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/kubemq.kubemq/SendRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/kubemq.kubemq/SendResponse", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Kubemq service

type KubemqServer interface {
	SendEvent(context.Context, *Event) (*Result, error)
	SendEventsStream(Kubemq_SendEventsStreamServer) error
	SubscribeToEvents(*Subscribe, Kubemq_SubscribeToEventsServer) error
	SubscribeToRequests(*Subscribe, Kubemq_SubscribeToRequestsServer) error
	SendRequest(context.Context, *Request) (*Response, error)
	SendResponse(context.Context, *Response) (*Empty, error)
}

func RegisterKubemqServer(s *grpc.Server, srv KubemqServer) {
	s.RegisterService(&_Kubemq_serviceDesc, srv)
}

func _Kubemq_SendEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendEventsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).SendEventsStream(&kubemqSendEventsStreamServer{stream})
}

type Kubemq_SendEventsStreamServer interface {
	Send(*Result) error
	Recv() (*Event, error)
	grpc.ServerStream
}

type kubemqSendEventsStreamServer struct {
	grpc.ServerStream
}

func (x *kubemqSendEventsStreamServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqSendEventsStreamServer) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_SubscribeToEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubemqServer).SubscribeToEvents(m, &kubemqSubscribeToEventsServer{stream})
}

type Kubemq_SubscribeToEventsServer interface {
	Send(*EventReceive) error
	grpc.ServerStream
}

type kubemqSubscribeToEventsServer struct {
	grpc.ServerStream
}

func (x *kubemqSubscribeToEventsServer) Send(m *EventReceive) error {
	return x.ServerStream.SendMsg(m)
}

func _Kubemq_SubscribeToRequests_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubemqServer).SubscribeToRequests(m, &kubemqSubscribeToRequestsServer{stream})
}

type Kubemq_SubscribeToRequestsServer interface {
	Send(*Request) error
	grpc.ServerStream
}

type kubemqSubscribeToRequestsServer struct {
	grpc.ServerStream
}

func (x *kubemqSubscribeToRequestsServer) Send(m *Request) error {
	return x.ServerStream.SendMsg(m)
}

func _Kubemq_SendRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendRequest(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendResponse(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

var _Kubemq_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kubemq.kubemq",
	HandlerType: (*KubemqServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendEvent",
			Handler:    _Kubemq_SendEvent_Handler,
		},
		{
			MethodName: "SendRequest",
			Handler:    _Kubemq_SendRequest_Handler,
		},
		{
			MethodName: "SendResponse",
			Handler:    _Kubemq_SendResponse_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendEventsStream",
			Handler:       _Kubemq_SendEventsStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeToEvents",
			Handler:       _Kubemq_SubscribeToEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToRequests",
			Handler:       _Kubemq_SubscribeToRequests_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "kubemq.proto",
}

func init() { proto.RegisterFile("kubemq.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 816 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4d, 0x6f, 0xda, 0x4c,
	0x10, 0xc6, 0x5f, 0x7c, 0x0c, 0x04, 0x36, 0x1b, 0x14, 0x59, 0xbc, 0x91, 0x5e, 0x5e, 0x9f, 0x38,
	0xbc, 0x42, 0x29, 0x3d, 0xf4, 0x14, 0xa9, 0x4d, 0x42, 0xd2, 0x2a, 0x49, 0xab, 0xac, 0x49, 0xef,
	0x06, 0xb6, 0x8a, 0x15, 0xfc, 0x11, 0x7b, 0x9d, 0x94, 0x7f, 0xd2, 0x4b, 0x6e, 0x3d, 0x55, 0xfd,
	0x07, 0xfd, 0x21, 0xfd, 0x3b, 0xd5, 0xae, 0x3f, 0xb0, 0x0d, 0xa4, 0x6a, 0x6f, 0xfb, 0xcc, 0xce,
	0x33, 0x7e, 0x98, 0x99, 0x9d, 0x01, 0x5a, 0x77, 0xd1, 0x94, 0x3a, 0xf7, 0x43, 0x3f, 0xf0, 0x98,
	0x87, 0xab, 0x31, 0x32, 0x6a, 0xa0, 0x8d, 0x1d, 0x9f, 0x2d, 0x8d, 0x4b, 0xa8, 0x12, 0x1a, 0x46,
	0x0b, 0x86, 0x75, 0xa8, 0x8d, 0x1f, 0xa8, 0xcb, 0xde, 0x9d, 0xea, 0x52, 0x5f, 0x1a, 0x34, 0x48,
	0x0a, 0x31, 0x06, 0xd5, 0xa4, 0x2e, 0xd3, 0xe5, 0xbe, 0x34, 0xa8, 0x13, 0x71, 0xc6, 0x5d, 0xd0,
	0xc6, 0x41, 0xe0, 0x05, 0xba, 0x22, 0x7c, 0x63, 0x60, 0x3c, 0x49, 0xa0, 0x09, 0xd6, 0x33, 0xd1,
	0x7a, 0x50, 0x3f, 0x59, 0xd8, 0xf1, 0x95, 0x2c, 0xae, 0x32, 0xcc, 0x59, 0x27, 0xb7, 0x96, 0xeb,
	0xd2, 0x45, 0x12, 0x37, 0x85, 0x9c, 0x75, 0x45, 0x99, 0x35, 0xb7, 0x98, 0xa5, 0xab, 0x31, 0x2b,
	0xc5, 0x5c, 0xdf, 0xb1, 0x37, 0x5f, 0xea, 0x5a, 0x5f, 0x1a, 0xb4, 0x88, 0x38, 0x73, 0x7d, 0x26,
	0xf3, 0x02, 0xaa, 0x57, 0x85, 0xe8, 0x18, 0x18, 0xdf, 0x25, 0x68, 0x09, 0x1d, 0x84, 0xce, 0xa8,
	0xfd, 0x40, 0x9f, 0x91, 0x99, 0x93, 0x22, 0x6f, 0x97, 0xa2, 0x6c, 0x91, 0xa2, 0xe6, 0xa4, 0x1c,
	0x40, 0x63, 0x62, 0x3b, 0x34, 0x64, 0x96, 0xe3, 0x0b, 0x8d, 0x0a, 0x59, 0x19, 0x78, 0x34, 0x93,
	0xde, 0x47, 0xd4, 0x9d, 0xc5, 0x5a, 0x55, 0x92, 0x61, 0xe3, 0x87, 0x0a, 0x0d, 0x33, 0x9a, 0x86,
	0xb3, 0xc0, 0x9e, 0x52, 0x7c, 0x05, 0xbb, 0x19, 0x98, 0x2c, 0x7d, 0x7a, 0xca, 0x05, 0x70, 0xd5,
	0xed, 0xd1, 0xbf, 0xc3, 0xa4, 0xca, 0x99, 0xc3, 0xb0, 0xe0, 0x4a, 0xd6, 0x99, 0x7f, 0x59, 0x87,
	0x2e, 0x68, 0xe7, 0x81, 0x17, 0xf9, 0x49, 0x11, 0x62, 0x80, 0x4d, 0xd8, 0x13, 0x79, 0x0b, 0x45,
	0x9a, 0x33, 0x71, 0x9a, 0x10, 0xf7, 0xdf, 0xba, 0xb8, 0x92, 0x33, 0xd9, 0xc4, 0xc6, 0x23, 0xe8,
	0x96, 0xcc, 0x1f, 0xad, 0x45, 0x14, 0x67, 0x49, 0x21, 0x1b, 0xef, 0x8c, 0x19, 0xec, 0x14, 0x7e,
	0x29, 0xee, 0xc1, 0x7e, 0xc1, 0x70, 0xe3, 0xce, 0xe9, 0x27, 0xdb, 0xa5, 0x73, 0x54, 0xc1, 0x00,
	0xd5, 0x38, 0x08, 0x92, 0x70, 0x07, 0x9a, 0xb9, 0x80, 0x48, 0xc6, 0x2d, 0xa8, 0x9f, 0x78, 0x8e,
	0x63, 0xb9, 0xf3, 0x10, 0x29, 0xb8, 0x09, 0xb5, 0xeb, 0x88, 0x06, 0x36, 0x0d, 0x91, 0x6a, 0x7c,
	0x95, 0xa0, 0x53, 0xfa, 0x3a, 0x3e, 0x00, 0xbd, 0x64, 0xca, 0x7f, 0x09, 0x41, 0xcb, 0x64, 0x56,
	0xc0, 0xde, 0xd3, 0xc7, 0x0f, 0xee, 0x62, 0x89, 0x24, 0x8c, 0xa1, 0x2d, 0x2c, 0x67, 0x81, 0xe7,
	0x9c, 0xd9, 0x41, 0xc8, 0x90, 0x8c, 0x77, 0x61, 0x27, 0xb3, 0x5d, 0x5a, 0x21, 0x43, 0x0a, 0xde,
	0x83, 0x8e, 0x30, 0xbd, 0x61, 0x69, 0x53, 0x20, 0x95, 0x6b, 0x4d, 0x8c, 0xbc, 0x8d, 0x90, 0x86,
	0xbb, 0x80, 0x72, 0x86, 0x53, 0xba, 0x60, 0x16, 0xaa, 0x1a, 0x4f, 0x0a, 0xd4, 0x08, 0x67, 0x85,
	0x8c, 0xf7, 0x60, 0x72, 0xcc, 0x3a, 0x7d, 0x65, 0xc0, 0x63, 0xe8, 0x24, 0x20, 0x2b, 0x9d, 0x2c,
	0x4a, 0xf7, 0x4f, 0x5a, 0xba, 0xe4, 0x7a, 0x98, 0x73, 0x23, 0x65, 0x4e, 0xa1, 0xa3, 0x94, 0xed,
	0x1d, 0xa5, 0x6e, 0x7f, 0x4e, 0xda, 0x96, 0xe7, 0x54, 0xcd, 0x3d, 0x27, 0x03, 0x5a, 0x84, 0xfa,
	0x8b, 0x65, 0x1a, 0xae, 0x26, 0x38, 0x05, 0x1b, 0xff, 0x1a, 0xcf, 0x84, 0x17, 0x31, 0xbd, 0xde,
	0x97, 0x06, 0x1a, 0x49, 0xa1, 0xd0, 0x68, 0xcd, 0x6e, 0xe9, 0x05, 0x5d, 0xea, 0x8d, 0x44, 0x63,
	0x82, 0xb3, 0xbb, 0xc9, 0xe4, 0x52, 0x07, 0x41, 0xcb, 0xb0, 0x98, 0x81, 0xbe, 0xe5, 0xea, 0xcd,
	0x58, 0x09, 0x3f, 0x1b, 0x47, 0xd0, 0xcc, 0xa5, 0x00, 0xef, 0x03, 0xce, 0xc1, 0x1b, 0xf7, 0xce,
	0xf5, 0x1e, 0x5d, 0x54, 0xe1, 0xbd, 0x93, 0x74, 0x12, 0x92, 0x70, 0x03, 0x34, 0xde, 0x48, 0x4b,
	0x24, 0x1b, 0x5f, 0x64, 0xa8, 0x13, 0x1a, 0xfa, 0x9e, 0x1b, 0xd2, 0x42, 0xee, 0xa4, 0x52, 0xee,
	0x0a, 0xc5, 0x93, 0xcb, 0xc5, 0x2b, 0xe7, 0x43, 0xd9, 0x90, 0x8f, 0x3f, 0x9d, 0x9e, 0x69, 0x26,
	0xde, 0xda, 0x2c, 0x19, 0xa0, 0x19, 0x2e, 0x8e, 0xb3, 0xda, 0x86, 0x71, 0x36, 0xfe, 0x4c, 0x67,
	0x11, 0xa3, 0x73, 0x91, 0xfa, 0x3a, 0xc9, 0xf0, 0x6a, 0x67, 0x34, 0x72, 0x3b, 0x23, 0xcb, 0x2c,
	0xac, 0x32, 0x3b, 0xfa, 0x29, 0x43, 0xb2, 0xa9, 0xf0, 0xff, 0xd0, 0x30, 0xa9, 0x3b, 0x8f, 0xb7,
	0xca, 0x4e, 0xda, 0x8f, 0x02, 0xf6, 0xda, 0xab, 0xf6, 0xe4, 0x2b, 0xcc, 0xa8, 0xe0, 0x57, 0x80,
	0x32, 0xef, 0xd0, 0x64, 0x01, 0xb5, 0x9c, 0xdf, 0x92, 0x06, 0xd2, 0xa1, 0x84, 0x5f, 0xe7, 0x87,
	0xab, 0x17, 0xf3, 0xf1, 0xee, 0xda, 0xe4, 0xea, 0x75, 0x0b, 0xc1, 0x92, 0x35, 0x62, 0x54, 0x0e,
	0x25, 0x7c, 0x04, 0x7b, 0xb9, 0x08, 0x49, 0x7d, 0x36, 0xc6, 0xe8, 0x94, 0x5e, 0x95, 0xa0, 0x8f,
	0xa0, 0xc9, 0x95, 0xa7, 0x0f, 0xb6, 0xec, 0xd3, 0x43, 0x39, 0xd9, 0xa2, 0x65, 0x8c, 0x0a, 0x7e,
	0x01, 0xad, 0x98, 0x93, 0x34, 0xd1, 0x9a, 0x4f, 0x6f, 0xf5, 0xdb, 0xc5, 0xb6, 0xaf, 0x1c, 0xb7,
	0xbf, 0xc9, 0xcd, 0x8b, 0x68, 0x4a, 0xaf, 0xae, 0x87, 0xe7, 0x81, 0x3f, 0x9b, 0x56, 0xc5, 0xff,
	0x82, 0x97, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x7d, 0x54, 0x3c, 0x4a, 0x27, 0x08, 0x00, 0x00,
}
